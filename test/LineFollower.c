#pragma config(Sensor, S1,     lightRight,          sensorLightActive)
#pragma config(Sensor, S2,     lightCenter,         sensorLightActive)
#pragma config(Sensor, S3,     lightLeft,           sensorLightActive)
#pragma config(Sensor, S4,     sonar,               sensorSONAR)
#pragma config(Motor,  motorA,          motorA,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          motorB,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorC,        tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#if 0
/// Copyright (c) Michael Tsang. All rights reserved.
///
/// <module name="linefollower.c" />
///
/// <summary>
///   This module contains the main code.
/// </summary>
///
/// <remarks>
///   Environment: RobotC for Lego Mindstorms NXT.
/// </remarks>
#endif

#define MAX_LIGHT_SENSORS       3
#define MAX_LN_FOLLOWACTIONS    27

#include "..\lib\common.h"
#include "..\lib\trace.h"
#include "..\lib\button.h"
#include "..\lib\display.h"
#include "..\lib\sensor.h"
#include "..\lib\drive.h"
#include "..\lib\sm.h"
#include "..\lib\lnfollow.h"

#ifdef MOD_ID
  #undef MOD_ID
#endif
#define MOD_ID                  MOD_MAIN

//
// Trace info.
//
#define TRACE_MODULES           (MOD_MAIN)
#define TRACE_LEVEL             FUNC
#define MSG_LEVEL               INFO

//
// State machine event types.
//
#define EVTTYPE_BUTTON          (EVTTYPE_NONE + 1)
#define EVTTYPE_SENSOR          (EVTTYPE_NONE + 2)
#define EVTTYPE_DRIVE           (EVTTYPE_NONE + 3)

//
// Drive info.
//
#define WHEEL_CIRCUMFERENCE     6.81    // in inches
#define CLICKS_PER_REVOLUTION   360.0   // in clicks
#define CLICKS_PER_DISTANCE     (CLICKS_PER_REVOLUTION/WHEEL_CIRCUMFERENCE)
#define WHEELBASE_DISTANCE      4.44    // in inches
#define CLICKS_PER_DEGREE       (CLICKS_PER_DISTANCE*PI*WHEELBASE_DISTANCE/360)
#define MAX_DRIVE_POWER         100
#define KP                      0.2
#define KI                      0.0
#define KD                      0.0

//
// Sensor info.
//
#define THRESHOLD_LO_LEFTLIGHT    475
#define THRESHOLD_HI_LEFTLIGHT    565
#define THRESHOLD_LO_CENTERLIGHT  400
#define THRESHOLD_HI_CENTERLIGHT  493
#define THRESHOLD_LO_RIGHTLIGHT   478
#define THRESHOLD_HI_RIGHTLIGHT   592
#define THRESHOLD_LO_SONAR        40
#define THRESHOLD_HI_SONAR        50

//
// Line follower info.
//
#if 0
#define OVERSHOOT_DRIVE_STEP    10
#define OVERSHOOT_TURN_STEP     10
#define OVERSHOOT_MIN_DRIVE     20
#define OVERSHOOT_MAX_TURN      50
#endif

#define LFInitInvalid(o,i)      {o.Actions[i].powerDrive = 0; \
                                 o.Actions[i].powerTurn = 0; \
                                 o.Actions[i].powerDriveOverShoot = 0; \
                                 o.Actions[i].powerTurnOverShoot = 0; \
                                 o.Actions[i].desc = "NA";}
#define LFInitRight3(o,i)       {o.Actions[i].powerDrive = SPEED_MEDSLOW; \
                                 o.Actions[i].powerTurn = TURN_LARGE; \
                                 o.Actions[i].powerDriveOverShoot = SPEED_SLOW; \
                                 o.Actions[i].powerTurnOverShoot = TURN_HARD; \
                                 o.Actions[i].desc = "R3";}
#define LFInitRight2(o,i)       {o.Actions[i].powerDrive = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurn = TURN_MEDIUM; \
                                 o.Actions[i].powerDriveOverShoot = SPEED_MEDIUM; \
                                 o.Actions[i].powerTurnOverShoot = TURN_LARGE; \
                                 o.Actions[i].desc = "R2";}
#define LFInitRight1(o,i)       {o.Actions[i].powerDrive = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurn = TURN_SMALL; \
                                 o.Actions[i].powerDriveOverShoot = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurnOverShoot = TURN_SMALL; \
                                 o.Actions[i].desc = "R1";}
#define LFInitCenter(o,i)       {o.Actions[i].powerDrive = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurn = TURN_CENTER; \
                                 o.Actions[i].powerDriveOverShoot = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurnOverShoot = TURN_CENTER; \
                                 o.Actions[i].desc = "C";}
#define LFInitLeft1(o,i)        {o.Actions[i].powerDrive = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurn = -TURN_SMALL; \
                                 o.Actions[i].powerDriveOverShoot = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurnOverShoot = -TURN_SMALL; \
                                 o.Actions[i].desc = "L1";}
#define LFInitLeft2(o,i)        {o.Actions[i].powerDrive = SPEED_MEDFAST; \
                                 o.Actions[i].powerTurn = -TURN_MEDIUM; \
                                 o.Actions[i].powerDriveOverShoot = SPEED_MEDIUM; \
                                 o.Actions[i].powerTurnOverShoot = -TURN_LARGE; \
                                 o.Actions[i].desc = "L2";}
#define LFInitLeft3(o,i)        {o.Actions[i].powerDrive = SPEED_MEDSLOW; \
                                 o.Actions[i].powerTurn = -TURN_LARGE; \
                                 o.Actions[i].powerDriveOverShoot = SPEED_SLOW; \
                                 o.Actions[i].powerTurnOverShoot = -TURN_HARD; \
                                 o.Actions[i].desc = "L3";}

//
// Type definitions.
//
//
// Global data.
//
bool      g_fCalDrive = false;
BUTTON    g_Buttons;
DRIVE     g_Drive;
SENSOR    g_Sonar;
SM        g_AutoSM;
LNFOLLOW  g_LnFollow;

/// <summary>
///   This function handles the button notification events.
/// </summary>
///
/// <param name="button">
///   Points to the BUTTON structure that generated the event.
/// </param>
///
/// <returns> None. </returns>

void
ButtonEvent(
  __in BUTTON &button
  )
{
  TFuncName("ButtonEvent");
  TEnterMsg(EVENT, ("Button=%x,On=%d", button.maskButton, (byte)button.fPressed));

  if (button.idJoystick == 1)
  {
    switch (button.maskButton)
    {
      case Xbox_A:
        if (button.fPressed)
        {
          if (IsSMDisabled(g_AutoSM))
          {
            SMStart(g_AutoSM);
          }
          else
          {
            SMStop(g_AutoSM);
          }
        }
        break;

      case Xbox_B:
        if (IsSMDisabled(g_AutoSM) && button.fPressed)
        {
          if (LnFollowCalibrating(g_LnFollow))
          {
            //
            // We were in calibration mode, we are done.
            //
            LnFollowCal(g_LnFollow, false);
          }
          else
          {
            //
            // We weren't in calibration mode, start it.
            //
            LnFollowCal(g_LnFollow, true);
          }
        }
        break;

      case Xbox_X:
        if (IsSMDisabled(g_AutoSM) && button.fPressed)
        {
          //
          // We only do calibration in teleop mode.
          // Do a PID distance calibration, drive forward 9 ft.
          //
          if (g_fCalDrive)
          {
            g_fCalDrive = false;
          }
          else
          {
            DrivePIDSetDistance(g_Drive, 108.0, 30);
            g_fCalDrive = true;
          }
        }
        break;

      case Xbox_Y:
        if (IsSMDisabled(g_AutoSM) && button.fPressed)
        {
          //
          // We only do calibration in teleop mode.
          // Do a PID angle calibration, turn clockwise 360 degrees.
          //
          if (g_fCalDrive)
          {
            g_fCalDrive = false;
          }
          else
          {
            DrivePIDSetAngle(g_Drive, 360.0, 30);
            g_fCalDrive = true;
          }
        }
        break;

      default:
        break;
  	}
  }

	TExit(EVENT);
  return;
}   //ButtonEvent

/// <summary>
///   This function handles the sensor notification events.
/// </summary>
///
/// <param name="sensor">
///   Points to the SESNOR structure that generated the event.
/// </param>
///
/// <returns> None. </returns>

void
SensorEvent(
  __in SENSOR &sensor
  )
{
  TFuncName("SensorEvent");
  TEnterMsg(EVENT, ("Sensor=%d,Zone=%d", sensor.idSensor, sensor.zoneSensor));

  switch (sensor.idSensor)
  {
    case sonar:
      break;

    default:
      break;
  }

  TExit(EVENT);
  return;
}   //SensorEvent

/// <summary>
///   This function handles the drive completion notification events.
/// </summary>
///
/// <param name="drive">
///   Points to the DRIVE structure that generated the event.
/// </param>
///
/// <returns> None. </returns>

void
DriveEvent(
  __in DRIVE &drive
  )
{
  TFuncName("DriveEvent");
  TEnterMsg(EVENT, ("Mode=%d", drive.modeDrive));

  if (IsSMEnabled(g_AutoSM))
  {
    //
    // In Autonomous mode.
    //
    SMSetEvent(g_AutoSM, EVTTYPE_DRIVE, drive.modeDrive, 0, 0, 0);
  }
  else
  {
    switch (drive.modeDrive)
    {
      case DRIVEMODE_PID_DISTANCE:
      case DRIVEMODE_PID_ANGLE:
        if (g_fCalDrive)
        {
          g_fCalDrive = false;
        }
        break;
    }
  }

  TExit(EVENT);
  return;
}   //DriveEvent

/// <summary>
///   This function implements the state machine for autonomous mode.
/// </summary>
///
/// <param name="sm">
///   Points to the SM structure.
/// </param>
///
/// <returns> None. </returns>

void
AutonomousSM(
  __inout SM &sm
  )
{
  TFuncName("AutonomousSM");
  TEnter(HIFREQ);

  if (IsSMReady(sm))
  {
    //
    // We only execute the autonomous state machine if it is not in wait mode.
    //
    LnFollowTask(g_LnFollow);
//    TInfo(("%03x=%s", (g_LnFollow.LightSensors[0].zoneSensor << 8) +
//                      (g_LnFollow.LightSensors[1].zoneSensor << 4) +
//                      g_LnFollow.LightSensors[2].zoneSensor,
//                      g_LnFollow.Actions[g_LnFollow.valueWeighted].desc));

    switch (sm.currState)
    {
      case SMSTATE_STARTED:
        if (g_LnFollow.valueWeighted == 0)
        {
          //
          // Don't see the line, drive forward full speed to find it.
          //
          DriveArcade(g_Drive, 100, 0);
        }
        else
        {
          sm.currState++;
        }
        break;

      case SMSTATE_STARTED + 1:
        DriveArcade(g_Drive, g_LnFollow.powerDrive, g_LnFollow.powerTurn);
        break;

      default:
        break;
    }
  }

  TExit(HIFREQ);
  return;
}   //AutonomousSM

/// <summary>
///   This function initializes the Line Follower action table.
/// </summary>
///
/// <returns> None. </returns>

void
InitLnFollowActions()
{
  TFuncName("InitLnFollowActions");
  TEnter(INIT);

#if 0
  g_LnFollow.ErrTable[0] = 0;   //0,0,0
  g_LnFollow.ErrTable[1] = 3;   //0,0,1
  g_LnFollow.ErrTable[2] = 2;   //0,0,2
  g_LnFollow.ErrTable[3] = 0;   //0,1,0
  g_LnFollow.ErrTable[4] = 1;   //0,1,1
  g_LnFollow.ErrTable[5] = 2;   //0,1,2
  g_LnFollow.ErrTable[6] = 0;   //0,2,0
  g_LnFollow.ErrTable[7] = 0;   //0,2,1
  g_LnFollow.ErrTable[8] = 1;   //0,2,2
  g_LnFollow.ErrTable[9] = -3;  //1,0,0
  g_LnFollow.ErrTable[10] = 0;  //1,0,1
  g_LnFollow.ErrTable[11] = 2;  //1,0,2
  g_LnFollow.ErrTable[12] = -1; //1,1,0
  g_LnFollow.ErrTable[13] = 0;  //1,1,1
  g_LnFollow.ErrTable[14] = 1;  //1,1,2
  g_LnFollow.ErrTable[15] = 0;  //1,2,0
  g_LnFollow.ErrTable[16] = 0;  //1,2,1
  g_LnFollow.ErrTable[17] = 1;  //1,2,2
  g_LnFollow.ErrTable[18] = -2; //2,0,0
  g_LnFollow.ErrTable[19] = -2; //2,0,1
  g_LnFollow.ErrTable[20] = 0;  //2,0,2
  g_LnFollow.ErrTable[21] = -2; //2,1,0
  g_LnFollow.ErrTable[22] = -1; //2,1,1
  g_LnFollow.ErrTable[23] = 0;  //2,1,2
  g_LnFollow.ErrTable[24] = -1; //2,2,0
  g_LnFollow.ErrTable[25] = -1; //2,2,1
  g_LnFollow.ErrTable[26] = 0;  //2,2,2
#endif
  LFInitInvalid(g_LnFollow, 0);         //0,0,0
  LFInitRight3(g_LnFollow, 1);          //0,0,1
  LFInitRight2(g_LnFollow, 2);          //0,0,2
  LFInitCenter(g_LnFollow, 3);          //0,1,0
  LFInitRight1(g_LnFollow, 4);          //0,1,1
  LFInitRight2(g_LnFollow, 5);          //0,1,2
  LFInitCenter(g_LnFollow, 6);          //0,2,0
  LFInitCenter(g_LnFollow, 7);          //0,2,1
  LFInitRight1(g_LnFollow, 8);          //0,2,2
  LFInitLeft3(g_LnFollow, 9);           //1,0,0
  LFInitInvalid(g_LnFollow, 10);        //1,0,1
  LFInitRight2(g_LnFollow, 11);         //1,0,2
  LFInitLeft1(g_LnFollow, 12);          //1,1,0
  LFInitCenter(g_LnFollow, 13);         //1,1,1
  LFInitRight1(g_LnFollow, 14);         //1,1,2
  LFInitCenter(g_LnFollow, 15);         //1,2,0
  LFInitCenter(g_LnFollow, 16);         //1,2,1
  LFInitRight1(g_LnFollow, 17);         //1,2,2
  LFInitLeft2(g_LnFollow, 18);          //2,0,0
  LFInitLeft2(g_LnFollow, 19);          //2,0,1
  LFInitInvalid(g_LnFollow, 20);        //2,0,2
  LFInitLeft2(g_LnFollow, 21);          //2,1,0
  LFInitLeft1(g_LnFollow, 22);          //2,1,1
  LFInitInvalid(g_LnFollow, 23);        //2,1,2
  LFInitLeft1(g_LnFollow, 24);          //2,2,0
  LFInitLeft1(g_LnFollow, 25);          //2,2,1
  LFInitCenter(g_LnFollow, 26);         //2,2,2

  TExit(INIT);
  return;
}   //InitLnFollowActions

/// <summary>
///   This function initializes the robot.
/// </summary>
///
/// <returns> None. </returns>

void
RobotInit()
{
  TFuncName("RobotInit");
  TEnter(INIT);

  InitLnFollowActions();
  LnFollowInit(g_LnFollow, MAX_LIGHT_SENSORS);
  SensorInit(g_LnFollow.LightSensors[0],
             lightLeft,
             THRESHOLD_LO_LEFTLIGHT,
             THRESHOLD_HI_LEFTLIGHT,
             SENSORF_INVERSE);
  SensorInit(g_LnFollow.LightSensors[1],
             lightCenter,
             THRESHOLD_LO_CENTERLIGHT,
             THRESHOLD_HI_CENTERLIGHT,
             SENSORF_INVERSE);
  SensorInit(g_LnFollow.LightSensors[2],
             lightRight,
             THRESHOLD_LO_RIGHTLIGHT,
             THRESHOLD_HI_RIGHTLIGHT,
             SENSORF_INVERSE);
  SensorInit(g_Sonar,
             sonar,
             THRESHOLD_LO_SONAR,
             THRESHOLD_HI_SONAR,
             0);
  ButtonInit(g_Buttons, 1, BTNF_ENABLE_EVENTS);
  DriveInit(g_Drive,
            motorC,     //Left motor
            motorB,     //Right motor
            CLICKS_PER_DISTANCE,
            CLICKS_PER_DEGREE,
            KP, KI, KD,
            DRIVEF_ENABLE_EVENTS);
  SMInit(g_AutoSM);
#if 0
  LnFollowInit(g_LnFollow, MAX_LIGHT_SENSORS,
               OVERSHOOT_DRIVE_STEP, OVERSHOOT_TURN_STEP,
               OVERSHOOT_MIN_DRIVE, OVERSHOOT_MAX_TURN);
#endif

  TExit(INIT);
  return;
}   //RobotInit

/// <summary>
///   This function processes all the input tasks.
/// </summary>
///
/// <returns> None. </returns>

void
InputTasks()
{
  TFuncName("InputTasks");
  TEnter(HIFREQ);

  getJoystickSettings(joystick);
  ButtonTask(g_Buttons);
  SensorTask(g_Sonar);

  TExit(HIFREQ);
  return;
}   //InputTasks

/// <summary>
///   This function processes all the main tasks.
/// </summary>
///
/// <returns> None. </returns>

void
MainTasks()
{
  TFuncName("MainTasks");
  TEnter(HIFREQ);

  int powerDrive = NORMALIZE(DEADBAND_INPUT(joystick.joy1_y1),
                             -128, 127, -MAX_DRIVE_POWER, MAX_DRIVE_POWER);
  int powerTurn = NORMALIZE(DEADBAND_INPUT(joystick.joy1_x1),
                            -128, 127, -MAX_DRIVE_POWER, MAX_DRIVE_POWER);

//#if 0
  nxtDisplayTextLine(0, "L: %d, %d",
                     g_LnFollow.LightSensors[0].zoneSensor,
                     g_LnFollow.LightSensors[0].valueSensor);
  nxtDisplayTextLine(1, "C: %d, %d",
                     g_LnFollow.LightSensors[1].zoneSensor,
                     g_LnFollow.LightSensors[1].valueSensor);
  nxtDisplayTextLine(2, "R: %d, %d",
                     g_LnFollow.LightSensors[2].zoneSensor,
                     g_LnFollow.LightSensors[2].valueSensor);
  nxtDisplayTextLine(3, "L: %d, %d",
                     g_LnFollow.LightSensors[0].valueThresholdLo,
                     g_LnFollow.LightSensors[0].valueThresholdHi);
  nxtDisplayTextLine(4, "C: %d, %d",
                     g_LnFollow.LightSensors[1].valueThresholdLo,
                     g_LnFollow.LightSensors[1].valueThresholdHi);
  nxtDisplayTextLine(5, "R: %d, %d",
                     g_LnFollow.LightSensors[2].valueThresholdLo,
                     g_LnFollow.LightSensors[2].valueThresholdHi);
//#endif
  if (IsSMEnabled(g_AutoSM))
  {
    //
    // Autonomous mode.
    //
    if ((powerDrive != 0) || (powerTurn != 0))
    {
      //
      // The user is overriding autonomous.
      //
      DriveArcade(g_Drive, powerDrive, powerTurn);
    }
    else
    {
      AutonomousSM(g_AutoSM);
    }
  }
  else if (!g_fCalDrive)
  {
    //
    // TeleOp mode.
    //
    DriveArcade(g_Drive, powerDrive, powerTurn);
  }

  TExit(HIFREQ);
  return;
}   //MainTasks

/// <summary>
///   This function processes all the output tasks.
/// </summary>
///
/// <returns> None. </returns>

void
OutputTasks()
{
  TFuncName("OutputTasks");
  TEnter(HIFREQ);

  DriveTask(g_Drive);

  TExit(HIFREQ);
  return;
}   //OutputTasks

/// <summary>
///   This task is the program entry point.
/// </summary>
///
/// <returns> None. </returns>

task main()
{
  TraceInit(TRACE_MODULES, TRACE_LEVEL, MSG_LEVEL);
  DisplayInit();
  RobotInit();
  while (true)
  {
    InputTasks();
    MainTasks();
    OutputTasks();
    wait10Msec(1);
  }
}   //main
