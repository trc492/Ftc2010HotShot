#pragma config(Sensor, S1,     lightRight,          sensorLightActive)
#pragma config(Sensor, S2,     lightCenter,         sensorLightActive)
#pragma config(Sensor, S3,     lightLeft,           sensorLightActive)
#pragma config(Sensor, S4,     sonar,               sensorSONAR)
#pragma config(Motor,  motorA,          motorA,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          motorB,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorC,        tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, S1,     Touch,               sensorTouch)
//#pragma config(Sensor, S2,     Sound,               sensorSoundDBA)
//#pragma config(Sensor, S3,     Light,               sensorLightActive)
//#pragma config(Sensor, S4,     Sonar,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#if 0
/// Copyright (c) Michael Tsang. All rights reserved.
///
/// <module name="gobbmobile.c" />
///
/// <summary>
///   This module contains the main code.
/// </summary>
///
/// <remarks>
///   Environment: RobotC for Lego Mindstorms NXT.
/// </remarks>
#endif

#include "..\lib\common.h"
#include "..\lib\trace.h"
#include "..\lib\button.h"
#include "..\lib\display.h"
#include "..\lib\sensor.h"
#include "..\lib\drive.h"
#include "..\lib\sm.h"
#include "grabber.h"

#ifdef MOD_ID
  #undef MOD_ID
#endif
#define MOD_ID                  MOD_MAIN

#define EVTTYPE_BUTTON          (EVTTYPE_NONE + 1)
#define EVTTYPE_SENSOR          (EVTTYPE_NONE + 2)
#define EVTTYPE_DRIVE           (EVTTYPE_NONE + 3)

//
// Drive info.
//
#define WHEEL_CIRCUMFERENCE     6.83    // in inches
#define CLICKS_PER_REVOLUTION   360.0   // in clicks
#define CLICKS_PER_DISTANCE     (CLICKS_PER_REVOLUTION/WHEEL_CIRCUMFERENCE)
#define WHEELBASE_DISTANCE      4.50    // in inches
#define CLICKS_PER_DEGREE       (CLICKS_PER_DISTANCE*PI*WHEELBASE_DISTANCE/360)
#define MAX_DRIVE_POWER         100
#define KP                      0.2
#define KI                      0.0
#define KD                      0.0

//
// Grabber info.
//
#define GRABBER_POWER_CALIBRATE 20
#define GRABBER_POWER_MAX       30
#define GRABBER_POS_MIN         10
#define GRABBER_POS_MAX         70
#define GRABBER_TIME_STEP       50

//
// Sensor mask.
//
#define SENSOR_MASK_LIGHTRIGHT  0x0001
#define SENSOR_MASK_LIGHTCENTER 0x0002
#define SENSOR_MASK_LIGHTLEFT   0x0004

#define THRESHOLD_LO_LIGHT      50
#define THRESHOLD_HI_LIGHT      50
#define THRESHOLD_LO_SONAR      40
#define THRESHOLD_HI_SONAR      50

#define DRIVESTATE_STOP         0
#define DRIVESTATE_SEEK_REGION  1
#define DRIVESTATE_OBSTACLE     2
#define DRIVESTATE_RESTRICTED   3
#define DRIVESTATE_BACKUP       4

//
// Line follower values.
//
#define SPEED_STOP              0
#define SPEED_VERYSLOW          10
#define SPEED_SLOW              20
#define SPEED_MEDSLOW           35
#define SPEED_MED               50
#define SPEED_MEDFAST           65
#define SPEED_FAST              80
#define SPEED_VERYFAST          90
#define SPEED_FULL              100

#define TURN_CENTER             0
#define TURN_SMALL              10
#define TURN_MEDIUM             20
#define TURN_LARGE              30
#define TURN_HARD               40

#define LFDRIVE_UNUSED  {SPEED_STOP,     TURN_CENTER, SPEED_STOP,     TURN_CENTER, "NA"}
#define LFDRIVE_RIGHT_3 {SPEED_MEDSLOW,  TURN_HARD,   SPEED_MEDSLOW,  TURN_LARGE,  "R3"}
#define LFDRIVE_RIGHT_2 {SPEED_MED,      TURN_LARGE,  SPEED_MED,      TURN_MEDIUM, "R2"}
#define LFDRIVE_RIGHT_1 {SPEED_MEDFAST,  TURN_SMALL,  SPEED_MEDFAST,  TURN_SMALL,  "R1"}
#define LFDRIVE_CENTER  {SPEED_MEDFAST,  TURN_CENTER, SPEED_MEDFAST,  TURN_CENTER, "C" }
#define LFDRIVE_LEFT_1  {SPEED_MEDFAST, -TURN_SMALL,  SPEED_MEDFAST, -TURN_SMALL,  "L1"}
#define LFDRIVE_LEFT_2  {SPEED_MED,     -TURN_LARGE,  SPEED_MED,     -TURN_MEDIUM, "L2"}
#define LFDRIVE_LEFT_3  {SPEED_MEDSLOW, -TURN_HARD,   SPEED_MEDSLOW, -TURN_LARGE,  "L3"}

#define InitLFUnused(e) {e.powerDrive = SPEED_STOP; \
                         e.powerTurn = TURN_CENTER; \
                         e.powerDriveOverShoot = SPEED_STOP; \
                         e.powerTurnOverShoot = TURN_CENTER; \
                         e.desc = "NA";}
#define InitLFRight3(e) {e.powerDrive = SPEED_MEDSLOW; \
                         e.powerTurn = TURN_HARD; \
                         e.powerDriveOverShoot = SPEED_MEDSLOW; \
                         e.powerTurnOverShoot = TURN_LARGE; \
                         e.desc = "R3";}
#define InitLFRight2(e) {e.powerDrive = SPEED_MED; \
                         e.powerTurn = TURN_LARGE; \
                         e.powerDriveOverShoot = SPEED_MED; \
                         e.powerTurnOverShoot = TURN_MEDIUM; \
                         e.desc = "R2";}
#define InitLFRight1(e) {e.powerDrive = SPEED_MEDFAST; \
                         e.powerTurn = TURN_SMALL; \
                         e.powerDriveOverShoot = SPEED_MEDFAST; \
                         e.powerTurnOverShoot = TURN_SMALL; \
                         e.desc = "R1";}
#define InitLFCenter(e) {e.powerDrive = SPEED_MEDFAST; \
                         e.powerTurn = TURN_CENTER; \
                         e.powerDriveOverShoot = SPEED_MEDFAST; \
                         e.powerTurnOverShoot = TURN_CENTER; \
                         e.desc = "C";}
#define InitLFLeft1(e)  {e.powerDrive = SPEED_MEDFAST; \
                         e.powerTurn = -TURN_SMALL; \
                         e.powerDriveOverShoot = SPEED_MEDFAST; \
                         e.powerTurnOverShoot = -TURN_SMALL; \
                         e.desc = "L1";}
#define InitLFLeft2(e)  {e.powerDrive = SPEED_MED; \
                         e.powerTurn = -TURN_LARGE; \
                         e.powerDriveOverShoot = SPEED_MED; \
                         e.powerTurnOverShoot = -TURN_MEDIUM; \
                         e.desc = "L2";}
#define InitLFLeft3(e)  {e.powerDrive = SPEED_MEDSLOW; \
                         e.powerTurn = -TURN_HARD; \
                         e.powerDriveOverShoot = SPEED_MEDSLOW; \
                         e.powerTurnOverShoot = -TURN_LARGE; \
                         e.desc = "L3";}

//
// Type definitions.
//
typedef struct
{
  int powerDrive;
  int powerTurn;
  int powerDriveOverShoot;
  int powerTurnOverShoot;
  string &desc;
} LFOLLOW;

//
// Global data.
//
BUTTON  g_Buttons;
DRIVE   g_Drive;
SENSOR  g_LeftLight;
SENSOR  g_CenterLight;
SENSOR  g_RightLight;
SENSOR  g_Sonar;
GRABBER g_Grabber;
SM      g_AutoSM;
LFOLLOW g_LineFollower[27];
#if 0
        {
/*0,0,0*/ LFDRIVE_UNUSED,
/*0,0,1*/ LFDRIVE_RIGHT_3,
/*0,0,2*/ LFDRIVE_RIGHT_2,
/*0,1,0*/ LFDRIVE_CENTER,
/*0,1,1*/ LFDRIVE_RIGHT_1,
/*0,1,2*/ LFDRIVE_RIGHT_2,
/*0,2,0*/ LFDRIVE_CENTER,
/*0,2,1*/ LFDRIVE_CENTER,
/*0,2,2*/ LFDRIVE_RIGHT_1,
/*1,0,0*/ LFDRIVE_LEFT_3,
/*1,0,1*/ LFDRIVE_UNUSED, //Should not happen
/*1,0,2*/ LFDRIVE_RIGHT_2,
/*1,1,0*/ LFDRIVE_LEFT_1,
/*1,1,1*/ LFDRIVE_CENTER,
/*1,1,2*/ LFDRIVE_RIGHT_1,
/*1,2,0*/ LFDRIVE_CENTER,
/*1,2,1*/ LFDRIVE_CENTER,
/*1,2,2*/ LFDRIVE_RIGHT_1,
/*2,0,0*/ LFDRIVE_LEFT_2,
/*2,0,1*/ LFDRIVE_LEFT_2,
/*2,0,2*/ LFDRIVE_UNUSED, //Should not happen
/*2,1,0*/ LFDRIVE_LEFT_2,
/*2,1,1*/ LFDRIVE_LEFT_1,
/*2,1,2*/ LFDRIVE_UNUSED, //Should not happen
/*2,2,0*/ LFDRIVE_LEFT_1,
/*2,2,1*/ LFDRIVE_LEFT_1,
/*2,2,2*/ LFDRIVE_CENTER
        };
#endif

/// <summary>
///   This function handles the button notification events.
/// </summary>
///
/// <param name="button">
///   Points to the BUTTON structure that generated the event.
/// </param>
///
/// <returns> None. </returns>

void
ButtonEvent(
  __in BUTTON &button
  )
{
  TFuncName("ButtonEvent");
  TEnterMsg(EVENT, ("Button=%x,On=%d", button.maskButton, (byte)button.fPressed));

  if (button.idJoystick == 1)
  {
    switch (button.maskButton)
    {
      case Xbox_A:
        if (button.fPressed)
        {
          if (IsSMDisabled(g_AutoSM))
          {
            SMStart(g_AutoSM);
          }
          else
          {
            SMStop(g_AutoSM);
          }
        }
        break;

      case Xbox_X:
        if (button.fPressed)
        {
          GrabberStartCal(g_Grabber);
        }
        break;

      default:
        break;
  	}
  }

	TExit(EVENT);
  return;
}   //ButtonEvent

/// <summary>
///   This function handles the sensor notification events.
/// </summary>
///
/// <param name="sensor">
///   Points to the SENSOR structure that generated the event.
/// </param>
///
/// <returns> None. </returns>

void
SensorEvent(
  __in SENSOR &sensor
  )
{
  TFuncName("SensorEvent");
  TEnterMsg(EVENT, ("Sensor=%d,Zone=%d", sensor.idSensor, sensor.zoneSensor));

  switch (sensor.idSensor)
  {
    case lightLeft:
    case lightCenter:
    case lightRight:
      break;

    case sonar:
      break;

    default:
      break;
  }

  TExit(EVENT);
  return;
}   //SensorEvent

/// <summary>
///   This function handles the drive completion notification events.
/// </summary>
///
/// <param name="drive">
///   Points to the DRIVE structure that generated the event.
/// </param>
///
/// <returns> None. </returns>

void
DriveEvent(
  __in DRIVE &drive
  )
{
  TFuncName("DriveEvent");
  TEnterMsg(EVENT, ("Mode=%d", drive.modeDrive));

  if (IsSMEnabled(g_AutoSM))
  {
    //
    // In Autonomous mode.
    //
    SMSetEvent(g_AutoSM, EVTTYPE_DRIVE, drive.modeDrive, 0, 0, 0);
  }
#if 0
  switch (DriveState)
  {
    case
  }
  static int distanceObstacle = 0;
  static int powerTurn = -30;

  if (!fAutonomous)
  {
    DriveProportional(driveInfo, joystick.joy1_y1, joystick.joy1_x1);
  }
  else
  {
    if ((DEADBAND_INPUT(joystick.joy1_y1) != 0) ||
        (DEADBAND_INPUT(joystick.joy1_x1) != 0))
    {
      //
      // The user is overriding autonomous.
      //
      DriveProportional(driveInfo, joystick.joy1_y1, joystick.joy1_x1);
      driveInfo.bAutoState = AUTOSTATE_NORMAL;
    }
    else
    {
      switch (driveInfo.bAutoState)
      {
        case AUTOSTATE_NORMAL:
          //
          // Drive straight ahead.
          //
          if (fObstacleAhead)
          {
            //
            // Obstacle ahead, turn to avoid it.
            //
            distanceObstacle = SensorValue(Sonar);
            driveInfo.bAutoState = AUTOSTATE_OBSTACLE;
          }
          else if (fDarkZone)
          {
            //
            // Entering restricted zone.
            //
            driveInfo.bAutoState = AUTOSTATE_RESTRICTED;
          }
          else
          {
            DriveProportional(driveInfo, 50, 0);
          }
          break;

        case AUTOSTATE_OBSTACLE:
          if (!fObstacleAhead)
          {
            driveInfo.bAutoState = AUTOSTATE_NORMAL;
          }
          else
          {
            if (distanceObstacle - SensorValue(Sonar) > THRESHOLD_OBSTACLE_DELTA)
            {
              //
              // Wrong direction, turn the other way.
              //
              powerTurn *= -1;
            }
            DriveProportional(driveInfo, 30, powerTurn);
          }
          break;

        case AUTOSTATE_RESTRICTED:
          if (fObstacleAhead)
          {
            //
            // Obstacle ahead, turn to avoid it.
            //
            distanceObstacle = SensorValue(Sonar);
            driveInfo.bAutoState = AUTOSTATE_OBSTACLE;
          }
          else if (fDarkZone)
          {
            DriveProportional(driveInfo, 50, 0);
          }
          else
          {
            //
            // We exited the restriced zone, back up.
            //
            driveInfo.bAutoState = AUTOSTATE_BACKUP;
          }
          break;

        case AUTOSTATE_BACKUP:
          if (fDarkZone)
          {
            DriveTurnWithEncoders(driveInfo, 20, 20, true);
            driveInfo.bAutoState = AUTOSTATE_RESTRICTED;
          }
          else
          {
            DriveProportional(driveInfo, -20, 0);
          }
          break;
      }
    }
  }
#endif

  TExit(EVENT);
  return;
}   //DriveEvent

/// <summary>
///   This function implements the state machine for autonomous mode.
/// </summary>
///
/// <param name="sm">
///   Points to the SM structure.
/// </param>
///
/// <returns> None. </returns>

void
AutonomousSM(
  __inout SM &sm
  )
{
  TFuncName("AutonomousSM");
  TEnter(HIFREQ);

  if (IsSMReady(sm))
  {
    //
    // We only execute the autonomous state machine if it is not in wait mode.
    //
    static int prevValue = 0;
    int currValue = g_LeftLight.zoneSensor*9 +
                    g_CenterLight.zoneSensor*3 +
                    g_RightLight.zoneSensor;

    switch (sm.currState)
    {
      case SMSTATE_STARTED:
#if 0
//        DrivePIDSetAngle(g_Drive, 360.0, 30);
//        SMAddWaitEvent(sm, EVTTYPE_DRIVE, DRIVEMODE_PID_ANGLE, -1);
        DrivePIDSetDistance(g_Drive, 108.0, 30);
        SMAddWaitEvent(sm, EVTTYPE_DRIVE, DRIVEMODE_PID_DISTANCE, -1);
        SMWaitEvents(sm, SMSTATE_DISABLED, SMF_CLEAR_EVENTS);
#endif
        if (currValue == 0)
        {
          //
          // Don't see the line, drive forward full speed.
          //
          DriveArcade(g_Drive, 100, 0);
        }
        else
        {
          sm.currState++;
        }
        break;

      case SMSTATE_STARTED + 1:
        if ((currValue == 0) ||
            (g_LineFollower[currValue].powerDrive == SPEED_STOP) &&
            (g_LineFollower[currValue].powerTurn == TURN_CENTER))
        {
          currValue = prevValue;
        }
        DriveArcade(g_Drive,
                    g_LineFollower[currValue].powerDrive,
                    g_LineFollower[currValue].powerTurn);
        prevValue = currValue;
        break;

      default:
        break;
    }
  }

  TExit(HIFREQ);
  return;
}   //AutonomousSM

/// <summary>
///   This function initializes the Line Follower.
/// </summary>
///
/// <returns> None. </returns>

void
LineFollowerInit()
{
  TFuncName("LineFollowerInit");
  TEnter(INIT);

  InitLFUnused(g_LineFollower[0]);
  InitLFRight3(g_LineFollower[1]);
  InitLFRight2(g_LineFollower[2]);
  InitLFCenter(g_LineFollower[3]);
  InitLFRight1(g_LineFollower[4]);
  InitLFRight2(g_LineFollower[5]);
  InitLFCenter(g_LineFollower[6]);
  InitLFCenter(g_LineFollower[7]);
  InitLFRight1(g_LineFollower[8]);
  InitLFLeft3(g_LineFollower[9]);
  InitLFUnused(g_LineFollower[10]);
  InitLFRight2(g_LineFollower[11]);
  InitLFLeft1(g_LineFollower[12]);
  InitLFCenter(g_LineFollower[13]);
  InitLFRight1(g_LineFollower[14]);
  InitLFCenter(g_LineFollower[15]);
  InitLFCenter(g_LineFollower[16]);
  InitLFRight1(g_LineFollower[17]);
  InitLFLeft2(g_LineFollower[18]);
  InitLFLeft2(g_LineFollower[19]);
  InitLFUnused(g_LineFollower[20]);
  InitLFLeft2(g_LineFollower[21]);
  InitLFLeft1(g_LineFollower[22]);
  InitLFUnused(g_LineFollower[23]);
  InitLFLeft1(g_LineFollower[24]);
  InitLFLeft1(g_LineFollower[25]);
  InitLFCenter(g_LineFollower[26]);

  TExit(INIT);
  return;
}   //LineFollowerInit

/// <summary>
///   This function initializes the robot.
/// </summary>
///
/// <returns> None. </returns>

void
RobotInit()
{
  TFuncName("RobotInit");
  TEnter(INIT);

  LineFollowerInit();
  ButtonInit(g_Buttons, 1, BTNF_ENABLE_EVENTS);
  DriveInit(g_Drive,
            motorC,     //Left motor
            motorB,     //Right motor
            CLICKS_PER_DEGREE,
            MAX_DRIVE_POWER,
            KP, KI, KD,
            DRIVEF_ENABLE_EVENTS);
  SensorInit(g_LeftLight,
             lightLeft,
             THRESHOLD_LO_LIGHT,
             THRESHOLD_HI_LIGHT,
             SENSORF_INVERSE);
  SensorInit(g_CenterLight,
             lightCenter,
             THRESHOLD_LO_LIGHT,
             THRESHOLD_HI_LIGHT,
             SENSORF_INVERSE);
  SensorInit(g_RightLight,
             lightRight,
             THRESHOLD_LO_LIGHT,
             THRESHOLD_HI_LIGHT,
             SENSORF_INVERSE);
  SensorInit(g_Sonar,
             sonar,
             THRESHOLD_LO_SONAR,
             THRESHOLD_HI_SONAR,
             0);
  GrabberInit(g_Grabber,
              motorA,
              GRABBER_POWER_CALIBRATE,
              GRABBER_POWER_MAX,
              GRABBER_POS_MIN,
              GRABBER_POS_MAX,
              GRABBER_TIME_STEP);
  SMInit(g_AutoSM);

  TExit(INIT);
  return;
}   //RobotInit

/// <summary>
///   This function processes all the input tasks.
/// </summary>
///
/// <returns> None. </returns>

void
InputTasks()
{
  TFuncName("InputTasks");
  TEnter(HIFREQ);

  getJoystickSettings(joystick);
  ButtonTask(g_Buttons);
  SensorTask(g_LeftLight);
  SensorTask(g_CenterLight);
  SensorTask(g_RightLight);
  SensorTask(g_Sonar);

  TExit(HIFREQ);
  return;
}   //InputTasks

/// <summary>
///   This function processes all the main tasks.
/// </summary>
///
/// <returns> None. </returns>

void
MainTasks()
{
  TFuncName("MainTasks");
  TEnter(HIFREQ);

  int powerDrive = NORMALIZE(DEADBAND_INPUT(joystick.joy1_y1),
                             -128, 127, -MAX_DRIVE_POWER, MAX_DRIVE_POWER);
  int powerTurn = NORMALIZE(DEADBAND_INPUT(joystick.joy1_x1),
                            -128, 127, -MAX_DRIVE_POWER, MAX_DRIVE_POWER);
  int powerGrabber = NORMALIZE(joystick.joy1_x2, -128, 127, -GRABBER_POWER_MAX, GRABBER_POWER_MAX);

  nxtDisplayTextLine(1, "Left  : %d", SensorValue[lightLeft]);
  nxtDisplayTextLine(2, "Center: %d", SensorValue[lightCenter]);
  nxtDisplayTextLine(3, "Right : %d", SensorValue[lightRight]);
  if (IsSMDisabled(g_AutoSM))
  {
    //
    // TeleOp mode.
    //
    nxtDisplayTextLine(0, "Mode=TeleOp");
    DriveArcade(g_Drive, powerDrive, powerTurn);
  }
  else
  {
    //
    // Autonomous mode.
    //
    nxtDisplayTextLine(0, "Mode=Auto");
#if 0
    if ((powerDrive != 0) || (powerTurn != 0))
    {
      //
      // The user is overriding autonomous.
      //
      DriveSetCruise(g_Drive, powerDrive, powerTurn);
    }
    else
    {
      AutonomousSM(g_AutoSM);
    }
#endif
    AutonomousSM(g_AutoSM);
  }
  GrabberSetPower(g_Grabber, powerGrabber);

  TExit(HIFREQ);
  return;
}   //MainTasks

/// <summary>
///   This function processes all the output tasks.
/// </summary>
///
/// <returns> None. </returns>

void
OutputTasks()
{
  TFuncName("OutputTasks");
  TEnter(HIFREQ);

  DriveTask(g_Drive);
  GrabberTask(g_Grabber);

  TExit(HIFREQ);
  return;
}   //OutputTasks

/// <summary>
///   This task is the program entry point.
/// </summary>
///
/// <returns> None. </returns>

task main()
{
  TraceInit(MOD_MAIN | MOD_GRABBER, FUNC, INFO);
  DisplayInit();
  RobotInit();
  while (true)
  {
    InputTasks();
    MainTasks();
    OutputTasks();
    wait10Msec(1);
  }
}   //main
